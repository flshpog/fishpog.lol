<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minesweeper — Single File</title>
  <style>
    :root{--cell-size:32px;--gap:4px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial}
    body{display:flex;min-height:100vh;align-items:center;justify-content:center;background:#0f172a;color:#e6eef8;margin:0}
    .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center}
    header{display:flex;gap:12px;align-items:center}
    .controls{display:flex;gap:8px;align-items:center}
    button,select{background:#111827;color:#e6eef8;border:1px solid #374151;padding:6px 10px;border-radius:6px;cursor:pointer}
    button:hover,select:hover{filter:brightness(1.05)}
    .status{display:flex;gap:12px;align-items:center}
    .display{background:#020617;padding:6px 10px;border-radius:8px;font-family:monospace;font-weight:700;border:2px solid #0f172a}
    #grid{display:grid;gap:var(--gap);padding:8px;background:linear-gradient(180deg,#0b1220,#061021);border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .cell{width:var(--cell-size);height:var(--cell-size);display:grid;place-items:center;background:linear-gradient(180deg,#1f2937,#111827);border-radius:6px;color:transparent;font-weight:800;user-select:none;cursor:pointer;border:2px solid rgba(255,255,255,0.02)}
    .cell.revealed{background:linear-gradient(180deg,#e6eef8,#d7e6ff);color:#0b1220;cursor:default}
    .cell.flagged{background:linear-gradient(180deg,#15303b,#0b4150);}
    .cell.mine{background:linear-gradient(180deg,#f87171,#ef4444);color:#111}
    .cell[data-num="1"]{color:#0b5cff}
    .cell[data-num="2"]{color:#008a2e}
    .cell[data-num="3"]{color:#b91c1c}
    .cell[data-num="4"]{color:#2b2b9a}
    .cell[data-num="5"]{color:#92278f}
    .cell[data-num="6"]{color:#0b6b6b}
    .cell[data-num="7"]{color:#000}
    .cell[data-num="8"]{color:#555}
    footer{font-size:12px;opacity:0.8}
    @media (max-width:600px){:root{--cell-size:28px}}
  </style>
</head>
<body>
  <div class="board-wrap">
    <header>
      <h1 style="margin:0;font-size:18px">Minesweeper</h1>
      <div class="controls">
        <label for="size">Size</label>
        <select id="size">
          <option value="9x9">9 × 9</option>
          <option value="16x16">16 × 16</option>
          <option value="16x30">16 × 30</option>
        </select>
        <label for="mines">Mines</label>
        <select id="mines">
          <option value="10">10</option>
          <option value="40">40</option>
          <option value="99">99</option>
        </select>
        <button id="new">New Game</button>
      </div>
      <div class="status">
        <div class="display" id="mineCount">Mines: 0</div>
        <div class="display" id="timer">Time: 0</div>
      </div>
    </header>

    <div id="grid" aria-label="Minesweeper grid"></div>
    <footer>Left click to reveal — Right click to flag. Double-click to quick-reveal neighbors. Mobile: long-press to flag.</footer>
  </div>

  <script>
    // Single-file Minesweeper
    const gridEl = document.getElementById('grid');
    const mineCountEl = document.getElementById('mineCount');
    const timerEl = document.getElementById('timer');
    const sizeSel = document.getElementById('size');
    const minesSel = document.getElementById('mines');
    const newBtn = document.getElementById('new');

    let rows=9, cols=9, mines=10;
    let cells = []; // array of cell objects
    let firstClick = true;
    let timer = null;
    let seconds = 0;
    let flagsRemaining = 0;
    let gameOver = false;

    function parseSize(v){
      const [r,c] = v.split('x').map(Number); return {r,c};
    }

    function initFromControls(){
      const s = parseSize(sizeSel.value); rows = s.r; cols = s.c; mines = Number(minesSel.value);
      flagsRemaining = mines; mineCountEl.textContent = `Mines: ${flagsRemaining}`;
      resetTimer(); firstClick=true; gameOver=false;
      renderGrid();
    }

    function resetTimer(){ clearInterval(timer); seconds=0; timerEl.textContent = 'Time: 0'; }

    function startTimer(){ if(timer) return; timer = setInterval(()=>{ seconds++; timerEl.textContent = `Time: ${seconds}`; },1000); }

    function renderGrid(){
      gridEl.innerHTML=''; cells = []; gridEl.style.gridTemplateColumns = `repeat(${cols}, auto)`;
      gridEl.style.gridTemplateRows = `repeat(${rows}, auto)`;
      gridEl.style.setProperty('--gap','4px');
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const idx = r*cols + c;
          const btn = document.createElement('button');
          btn.className='cell';
          btn.dataset.r = r; btn.dataset.c = c; btn.dataset.idx = idx;
          btn.setAttribute('aria-label',`cell ${r+1},${c+1}`);
          // event handlers
          btn.addEventListener('click', onLeftClick);
          btn.addEventListener('contextmenu', onRightClick);
          btn.addEventListener('dblclick', onDoubleClick);
          // mobile long press for flag
          let pressTimer;
          btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); pressTimer = setTimeout(()=>{ onRightClick(e); },600); });
          btn.addEventListener('touchend', ()=>{ clearTimeout(pressTimer); });

          gridEl.appendChild(btn);
          cells[idx] = {r,c,idx,btn, mine:false, revealed:false, flagged:false, adjacent:0};
        }
      }
    }

    function placeMines(seedR, seedC){
      // ensure first clicked tile and its neighbors are safe
      const safe = new Set();
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
        const rr = seedR+dr, cc = seedC+dc;
        if(rr>=0 && rr<rows && cc>=0 && cc<cols) safe.add(rr*cols+cc);
      }
      let placed=0;
      while(placed < mines){
        const r = Math.floor(Math.random()*rows);
        const c = Math.floor(Math.random()*cols);
        const idx = r*cols + c;
        if(safe.has(idx)) continue;
        if(!cells[idx].mine){ cells[idx].mine = true; placed++; }
      }
      // compute adjacent numbers
      for(const cell of cells){ if(cell.mine) continue; let count=0; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const rr=cell.r+dr, cc=cell.c+dc; if(rr>=0&&rr<rows&&cc>=0&&cc<cols){ if(cells[rr*cols+cc].mine) count++; } } cell.adjacent = count; }
    }

    function revealCell(cell){
      if(gameOver || cell.revealed || cell.flagged) return;
      cell.revealed = true; cell.btn.classList.add('revealed');
      if(cell.mine){ cell.btn.classList.add('mine'); cell.btn.textContent = '💣'; loseGame(); return; }
      if(cell.adjacent>0){ cell.btn.dataset.num = cell.adjacent; cell.btn.textContent = cell.adjacent; }
      else{ cell.btn.textContent = ''; // flood fill neighbors
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const rr=cell.r+dr, cc=cell.c+dc; if(rr>=0&&rr<rows&&cc>=0&&cc<cols){ revealCell(cells[rr*cols+cc]); } }
      }
      checkWin();
    }

    function onLeftClick(e){
      if(gameOver) return;
      const btn = e.currentTarget; const idx = Number(btn.dataset.idx); const cell = cells[idx];
      if(firstClick){ placeMines(cell.r, cell.c); firstClick=false; startTimer(); }
      revealCell(cell);
    }

    function onRightClick(e){
      e.preventDefault(); if(gameOver) return;
      const btn = e.currentTarget; const idx = Number(btn.dataset.idx); const cell = cells[idx];
      if(!cell.revealed){
        cell.flagged = !cell.flagged;
        if(cell.flagged){ btn.classList.add('flagged'); btn.textContent='🚩'; flagsRemaining--; }
        else{ btn.classList.remove('flagged'); btn.textContent=''; flagsRemaining++; }
        mineCountEl.textContent = `Mines: ${flagsRemaining}`;
      }
      checkWin();
    }

    function onDoubleClick(e){
      // quick reveal: if number revealed and flagged neighbors == number, reveal other neighbors
      const btn = e.currentTarget; const idx = Number(btn.dataset.idx); const cell = cells[idx];
      if(!cell.revealed || cell.adjacent===0) return;
      let flagged=0; let neighbors = [];
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const rr=cell.r+dr, cc=cell.c+dc; if(rr>=0&&rr<rows&&cc>=0&&cc<cols){ const n = cells[rr*cols+cc]; neighbors.push(n); if(n.flagged) flagged++; } }
      if(flagged === cell.adjacent){ neighbors.forEach(n=>{ if(!n.flagged && !n.revealed) revealCell(n); }); }
    }

    function loseGame(){
      gameOver = true; clearInterval(timer); // reveal all mines
      cells.forEach(c=>{ if(c.mine){ c.btn.classList.add('revealed','mine'); if(!c.flagged) c.btn.textContent='💣'; } if(c.flagged && !c.mine){ c.btn.textContent='❌'; } });
      setTimeout(()=>alert('Game Over — You hit a mine!'),50);
    }

    function checkWin(){
      if(gameOver) return;
      const unrevealed = cells.filter(c=>!c.revealed).length;
      if(unrevealed === mines){ winGame(); }
    }

    function winGame(){ gameOver=true; clearInterval(timer); setTimeout(()=>alert(`You Win! Time: ${seconds}s`),50); }

    // wire controls
    newBtn.addEventListener('click', ()=>{ initFromControls(); });
    sizeSel.addEventListener('change', ()=>{ const s=parseSize(sizeSel.value); // update mines dropdown reasonable default
      if(sizeSel.value==='9x9') minesSel.value='10';
      if(sizeSel.value==='16x16') minesSel.value='40';
      if(sizeSel.value==='16x30') minesSel.value='99';
    });

    // initial render
    initFromControls();
  </script>
</body>
</html>
